package crypto

import (
	"crypto"
	"crypto/rsa"
	"crypto/rand"
	"crypto/x509"
	"encoding/pem"
	"github.com/kmgreen2/agglo/pkg/util"
	"hash"
	"reflect"
)

///
// RSA implementations of Signature, Authenticator and Signer
///

// RSAAuthenticator used to verify a signature using a public key
type RSAAuthenticator struct {
	publicKey *rsa.PublicKey
	hashAlgorithm crypto.Hash
}

// RSASigner will sign a payload using a private key
type RSASigner struct {
	privateKey *rsa.PrivateKey
	hashAlgorithm crypto.Hash
}

// RSASignature is the signature generated by a Signer
type RSASignature struct {
	signature []byte
	hashAlgorithm crypto.Hash
}

// Bytes will return the byte array representation of the signature
func (r *RSASignature) Bytes() []byte {
	return r.signature
}

// HashAlgorithm will return the hash algorithm used to compute the signature
func (r *RSASignature) HashAlgorithm() crypto.Hash {
	return r.hashAlgorithm
}

// PKAlgorithm will return the public-key algorithm used to compute the signature
// This will always return RSA
func (r *RSASignature) PKAlgorithm() x509.PublicKeyAlgorithm {
	return x509.RSA
}

// Helper function that ensured the authenticator's algorithms
// match those of the signature
func algorithmMatch(a *RSAAuthenticator, s Signature) bool {
	return (a.hashAlgorithm == s.HashAlgorithm() && s.PKAlgorithm() == x509.RSA)
}

// Verify the authenticity of a message using a provided signature.  Returns
// false if either the target algorithms do not match (hash+PK) or the signature
// does not match
func (a *RSAAuthenticator) Verify(message []byte, signature Signature) bool {
	var digest []byte
	var hash hash.Hash
	if !algorithmMatch(a, signature) {
		return false
	}

	switch(a.hashAlgorithm) {
	case crypto.SHA1:
		hash = util.InitHash(util.SHA1)
	case crypto.SHA256:
		hash = util.InitHash(util.SHA256)
	}
	hash.Write(message)
	digest = hash.Sum(nil)

	err := rsa.VerifyPKCS1v15(a.publicKey, a.hashAlgorithm, digest, signature.Bytes())

	if err != nil {
		return false
	}

	return true
}

// Sign a message using a RSASinger, which supports SHA1 and SHA256, depending on
// how the signer is instantiated.
func (s *RSASigner) Sign(message []byte) (Signature, error) {
	var digest []byte
	var hash hash.Hash

	switch(s.hashAlgorithm) {
	case crypto.SHA1:
		hash = util.InitHash(util.SHA1)
	case crypto.SHA256:
		hash = util.InitHash(util.SHA256)
	}
	hash.Write(message)
	digest = hash.Sum(nil)
	signature, err := rsa.SignPKCS1v15(rand.Reader, s.privateKey, s.hashAlgorithm, digest)

	if err != nil {
		return nil, err
	}

	return NewRSASignatureBytes(signature, s.hashAlgorithm), nil
}

// NewRSASigner will create a new RSASigner with a specific private key and hash algorithm
func NewRSASigner(privateKey *rsa.PrivateKey, hashAlgorithm crypto.Hash) *RSASigner {
	s := &RSASigner {
		privateKey: privateKey,
		hashAlgorithm: hashAlgorithm,
	}
	return s
}

// NewRSAAuthenticator will create a new RSAAuthenticator with a specific public key and hash algorithm
func NewRSAAuthenticator(publicKey *rsa.PublicKey, hashAlgorithm crypto.Hash) *RSAAuthenticator {
	a := &RSAAuthenticator{
		publicKey: publicKey,
		hashAlgorithm: hashAlgorithm,
	}
	return a
}

// NewRSASignatureBytes will create a new signature from the byte representation of the signature
func NewRSASignatureBytes(bytes []byte, hashAlgorithm crypto.Hash) *RSASignature {
	s := &RSASignature{
		signature: bytes,
		hashAlgorithm: hashAlgorithm,
	}
	return s
}

// SerialilzeRSAPublicKey will serialize RSA public key
func SerialilzeRSAPublicKey(publicKey *rsa.PublicKey) ([]byte, error) {
	bytes, err := x509.MarshalPKIXPublicKey(publicKey)

	if err != nil {
		return nil, err
	}

	return bytes, nil
}

// DeserialilzeRSAPublicKey will deserialize RSA public key
func DeserialilzeRSAPublicKey(bytes []byte) (*rsa.PublicKey, error) {
	publicKey, err := x509.ParsePKIXPublicKey(bytes)

	if err != nil {
		return nil, err
	}

	if reflect.TypeOf(publicKey) != reflect.TypeOf(&rsa.PublicKey{}) {
		return nil, err
	}

	return publicKey.(*rsa.PublicKey), err
}

// SerialilzeRSAPrivateKey will RSA private key
func SerialilzeRSAPrivateKey(privateKey *rsa.PrivateKey) ([]byte, error) {
	bytes := x509.MarshalPKCS1PrivateKey(privateKey)

	return bytes, nil
}

// DeserialilzeRSAPrivateKey will deserialize RSA private key
func DeserialilzeRSAPrivateKey(bytes []byte) (*rsa.PrivateKey, error) {
	privateKey, err := x509.ParsePKCS1PrivateKey(bytes)

	if err != nil {
		return nil, err
	}

	return privateKey, err
}

func ExportRSAPrivateKeyAsPEM(privateKey *rsa.PrivateKey) string {
	privateKeyBytes := x509.MarshalPKCS1PrivateKey(privateKey)
	privateKeyPEM := pem.EncodeToMemory(
		&pem.Block{
			Type:  "RSA PRIVATE KEY",
			Bytes: privateKeyBytes,
		},
	)
	return string(privateKeyPEM)
}

func ParseRSAPrivateKeyFromPEM(privateKeyPEM string) (*rsa.PrivateKey, error) {
	block, _ := pem.Decode([]byte(privateKeyPEM))
	if block == nil {
		return nil, util.NewInvalidError("failed to parse PEM block containing the key")
	}

	privateKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)
	if err != nil {
		return nil, err
	}

	return privateKey, nil
}

func ExportRSAPublicKeyAsPEM(publicKey *rsa.PublicKey) (string, error) {
	publicKeyBytes, err := x509.MarshalPKIXPublicKey(publicKey)
	if err != nil {
		return "", err
	}
	publicKeyPEM := pem.EncodeToMemory(
		&pem.Block{
			Type:  "RSA PUBLIC KEY",
			Bytes: publicKeyBytes,
		},
	)

	return string(publicKeyPEM), nil
}

func ParseRSAPublicKeyFromPEM(publicKeyPEM string) (*rsa.PublicKey, error) {
	block, _ := pem.Decode([]byte(publicKeyPEM))
	if block == nil {
		return nil, util.NewInvalidError("failed to parse PEM block containing the key")
	}

	pub, err := x509.ParsePKIXPublicKey(block.Bytes)
	if err != nil {
		return nil, err
	}

	switch pub := pub.(type) {
	case *rsa.PublicKey:
		return pub, nil
	}
	return nil, util.NewInvalidError("Key type is not RSA")
}
